name: ODS CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      microservice:
        description: 'Which microservice to build'
        required: true
        type: choice
        options:
          - ods.manager
          - ods.extractor
          - ods.data-access
          - rave-medidata
        default: ods.extractor

      aws_env:
        description: 'Which AWS environment to deploy to'
        required: true
        type: choice
        options:
          - sandbox
          - dev
          - qa
          - uat
          - prod
        default: sandbox

      dotnet_version:
        description: 'Dotnet version'
        required: true
        default: '9.0.x'

jobs:
  build_test_and_deploy:
    name: Build, Test, Push to ECR & Update Lambda
    runs-on: ubuntu-latest
    permissions: write-all
    
    steps:
      # 1) Checkout code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) Determine working directory for the microservice
      - name: Set WORK_DIR
        id: set_workdir
        run: |
          WORK_DIR="src/${{ github.event.inputs.microservice }}"
          echo "WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
          echo "Using microservice path: $WORK_DIR"

      # 3) Setup .NET
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ github.event.inputs.dotnet_version }}

      # 4) Install Dependencies
      - name: Install dependencies
        run: dotnet restore
        working-directory: ${{ env.WORK_DIR }}

      # 5) Build
      - name: Build
        run: dotnet build --no-restore --configuration Release
        working-directory: ${{ env.WORK_DIR }}

      # 6) Run Unit Tests
      - name: Run Unit Tests
        run: dotnet test --no-build --verbosity normal
        working-directory: ${{ env.WORK_DIR }}

      # 7) Generate Semantic Version
      - name: Generate Semantic Version
        id: semver
        uses: paulhatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          version_format: "${major}.${minor}.${patch}"
          major_pattern: "/^feat!:|^BREAKING CHANGE:/"
          minor_pattern: "/^feat:|^minor:/"
          major_regexp_flags: "i"
          minor_regexp_flags: "i"

      # 8) Map environment => AWS role & ECR repo + Lambda function name
      - name: Determine AWS Role, ECR_URI, & Lambda
        id: set_aws_ecr
        run: |
          ########################################
          # (A) Choose AWS Role based on aws_env
          ########################################
          if [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_PROD }}" >> $GITHUB_ENV
          else
            echo "❌ ERROR: Unrecognized aws_env '${{ github.event.inputs.aws_env }}'"
            exit 1
          fi

          ########################################
          # (B) Set ECR_URI and LAMBDA_FUNCTION based on microservice + environment
          ########################################
          # Extract the microservice name without ods. prefix for ECS service name
          MICROSERVICE_NAME=$(echo "${{ github.event.inputs.microservice }}" | sed 's/ods\.//')
          
          # Set repository name for informational purposes
          echo "REPO_NAME=theradex-${{ github.event.inputs.aws_env }}-${{ github.event.inputs.microservice }}" >> $GITHUB_ENV
          
          # ods.extractor
          if [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_PROD }}" >> $GITHUB_ENV
          
          # ods.manager
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_PROD }}" >> $GITHUB_ENV
          
          # ods.data-access
          elif [ "${{ github.event.inputs.microservice }}" = "ods.data-access" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_DATA_ACCESS_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.data-access" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_DATA_ACCESS_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.data-access" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_DATA_ACCESS_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.data-access" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_DATA_ACCESS_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.data-access" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_DATA_ACCESS_PROD }}" >> $GITHUB_ENV
          
          # rave-medidata
          elif [ "${{ github.event.inputs.microservice }}" = "rave-medidata" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_RAVE_MEDIDATA_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "rave-medidata" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_RAVE_MEDIDATA_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "rave-medidata" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_RAVE_MEDIDATA_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "rave-medidata" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_RAVE_MEDIDATA_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "rave-medidata" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_RAVE_MEDIDATA_PROD }}" >> $GITHUB_ENV
          
          else
            echo "❌ ERROR: Unrecognized microservice+env pair"
            exit 1
          fi

          echo "✅ Mapped AWS_ROLE_ARN, ECR_URI, and LAMBDA_FUNCTION."

      # 9) Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      # 10) Log in to Amazon ECR
      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_DEFAULT_REGION }} \
            | docker login --username AWS --password-stdin ${{ env.ECR_URI }}

      # 11) Build Docker Image
      - name: Build Docker Image
        run: |
          # Set up the correct working directory structure for Docker build
          echo "Building Docker image from directory: $WORK_DIR"
          echo "Current directory structure:"
          ls -la
          
          # The Dockerfile expects a specific structure, so we need to build from the src directory
          cd src
          
          # Build the Docker image with environment-specific tag
          docker build \
            -f ${{ github.event.inputs.microservice }}/Dockerfile \
            -t ${{ env.ECR_URI }}:${{ steps.semver.outputs.version }} \
            -t ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest \
            .


      # 12) Push Docker Image to ECR
      - name: Push Docker Image to ECR
        run: |
          docker push ${{ env.ECR_URI }}:${{ steps.semver.outputs.version }}
          docker push ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest

      # 13) Log deployment information
      - name: Log Deployment Info
        run: |
          echo "✅ Successfully pushed image to ECR: ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest"
          echo "✅ EventBridge will automatically deploy the new image"
          
          # Add information about the environment and microservice
          echo "Environment: ${{ github.event.inputs.aws_env }}"
          echo "Microservice: ${{ github.event.inputs.microservice }}"
          echo "ECR URI: ${{ env.ECR_URI }}:${{ steps.semver.outputs.version }}"

      # 14) Create GitHub Summary
      - name: Add Summary
        if: ${{ always() }}
        uses: actions/github-script@v6
        with:
          script: |
            const version = '${{ steps.semver.outputs.version }}';
            const env = '${{ github.event.inputs.aws_env }}';
            const microservice = '${{ github.event.inputs.microservice }}';
            const ecr = '${{ env.ECR_URI }}';
            const repoName = '${{ env.REPO_NAME }}';

            core.summary
              .addHeading("ODS Deployment Summary")
              .addTable([
                [{ data: "Version", header: true }, { data: "Environment", header: true }, { data: "Microservice", header: true }, { data: "Repository", header: true }],
                [version, env, microservice, repoName],
              ])
              .addHeading("Image Details")
              .addRaw(`ECR URI: ${ecr}:${version}`)
              .addRaw(`Latest Tag: ${ecr}:${env}-latest`)
              .write()

      # 15) (Optional) Save Docker Image as Artifact
      - name: Save Docker Image as Artifact
        run: |
          echo "Saving Docker image ${{ env.ECR_URI }}:${{ steps.semver.outputs.version }} as an artifact"
          docker save ${{ env.ECR_URI }}:${{ steps.semver.outputs.version }} | gzip > ods_${{ steps.semver.outputs.version }}.tar.gz

      # 16) (Optional) Upload Docker Image Artifact
      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ steps.semver.outputs.version }}
          path: ods_${{ steps.semver.outputs.version }}.tar.gz
