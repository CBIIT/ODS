name: ODS CI/CD Pipeline

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      microservice:
        description: 'Which microservice to build'
        required: true
        type: choice
        options:
          - ods.manager
          - ods.extractor
        default: ods.extractor

      aws_env:
        description: 'Which AWS environment to deploy to'
        required: true
        type: choice
        options:
          - sandbox
          - dev
          - qa
          - uat
          - prod
        default: sandbox

      dotnet_version:
        description: 'Dotnet version'
        required: true
        default: '9.0.x'

jobs:
  build_test_and_deploy:
    name: Build, Test, Push to ECR 
    runs-on: ubuntu-latest
    permissions: write-all
    environment:
      name: dev    
    steps:
      # 1) Checkout code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) Determine working directory for the microservice
      - name: Set WORK_DIR
        id: set_workdir
        run: |
          WORK_DIR="src/${{ github.event.inputs.microservice }}"
          echo "WORK_DIR=$WORK_DIR" >> $GITHUB_ENV
          echo "Using microservice path: $WORK_DIR"

      # 3) Setup .NET
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ github.event.inputs.dotnet_version }}

      # 4) Install Dependencies
      - name: Install dependencies
        run: dotnet restore
        working-directory: ${{ env.WORK_DIR }}

      # 5) Build
      - name: Build
        run: dotnet build --no-restore --configuration Release
        working-directory: ${{ env.WORK_DIR }}

      # 6) Run Unit Tests
      - name: Run Unit Tests
        run: dotnet test --no-build --verbosity normal
        working-directory: ${{ env.WORK_DIR }}

      # 7) Generate Semantic version
      - name: Generate Semantic version
        id: semver
        uses: paulhatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          version_format: "${major}.${minor}.${patch}"
          major_pattern: "/^feat!:|^BREAKING CHANGE:/"
          minor_pattern: "/^feat:|^minor:/"
          major_regexp_flags: "i"
          minor_regexp_flags: "i"

      # Create release
      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.semver.outputs.version_tag  }}
          tag_name: ${{ steps.semver.outputs.version_tag  }}
          fail_on_unmatched_files: true
          generate_release_notes: true          

      # Setup git config
      - name: Setup git config
        env:
          NEXT_TAG: ${{ steps.semver.outputs.version_tag  }}
        run: |
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'

          
      # 8) Map environment => AWS role & ECR repo + Lambda function name
      - name: Determine AWS Role, ECR_URI, & Lambda
        id: set_aws_ecr
        run: |
          ########################################
          # (A) Choose AWS Role based on aws_env
          ########################################
          if [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "AWS_ROLE_ARN=${{ secrets.AWS_ROLE_ARN_PROD }}" >> $GITHUB_ENV
          else
            echo "❌ ERROR: Unrecognized aws_env '${{ github.event.inputs.aws_env }}'"
            exit 1
          fi

          ########################################
          # (B) Set ECR_URI and LAMBDA_FUNCTION based on microservice + environment
          ########################################
          # Extract the microservice name without ods. prefix for ECS service name
          MICROSERVICE_NAME=$(echo "${{ github.event.inputs.microservice }}" | sed 's/ods\.//')
          
          # Set repository name for informational purposes
          echo "REPO_NAME=theradex-${{ github.event.inputs.aws_env }}-${{ github.event.inputs.microservice }}" >> $GITHUB_ENV
          
          # ods.extractor
          if [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.extractor" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_EXTRACTOR_PROD }}" >> $GITHUB_ENV
          
          # ods.manager
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "sandbox" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_SANDBOX }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "dev" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_DEV }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "qa" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_QA }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "uat" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_UAT }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.microservice }}" = "ods.manager" ] && [ "${{ github.event.inputs.aws_env }}" = "prod" ]; then
            echo "ECR_URI=${{ secrets.ECR_URI_ODS_MANAGER_PROD }}" >> $GITHUB_ENV
        
          else
            echo "❌ ERROR: Unrecognized microservice+env pair"
            exit 1
          fi

          echo "✅ Mapped AWS_ROLE_ARN, ECR_URI, and LAMBDA_FUNCTION."

      # 9) Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
          role-session-name: ${{ github.event.repository.name }}-${{ github.run_id }}
          role-duration-seconds: 3600
          
      # 10) Log in to Amazon ECR
      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_DEFAULT_REGION }} \
            | docker login --username AWS --password-stdin ${{ env.ECR_URI }}

      # 11) Build Docker Image
      - name: Build Docker Image
        run: |
          # Navigate to the root of the project
          cd ..
          # Build the Docker image with environment-specific tag
          docker build \
            -f ./${{ github.event.inputs.microservice }}/Dockerfile \
            -t ${{ env.ECR_URI }}:${{ steps.semver.outputs.version_tag }} \
            -t ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest \
            .

      # 11.5) Approval Step
      - name: Approval
        uses: actions/github-script@v6
        id: approval
        with:
          script: |
            const result = await github.rest.actions.createWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'manual-approval.yaml',
              ref: 'main',
              inputs: {
                environment: '${{ github.event.inputs.aws_env }}',
                microservice: '${{ github.event.inputs.microservice }}',
                version: '${{ steps.semver.outputs.version_tag }}'
              }
            });

            console.log(result);
            if (result.status !== 201) {
              core.setFailed(`Failed to trigger approval workflow: ${result.status}`);
            }
  
      - name: Wait for Approval
        uses: actions/github-script@v6
        if: ${{ always() && needs.build_test_and_deploy.result == 'success' }}
        with:
          script: |
            const approvalRunId = ${{ fromJson(steps.approval.result).data.workflow_runs[0].id }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let approvalState = 'pending';
            let approvalConclusion = null;

            while (approvalState !== 'completed') {
              const approvalCheck = await github.rest.actions.getWorkflowRun({
                owner: owner,
                repo: repo,
                run_id: approvalRunId,
              });

              approvalState = approvalCheck.data.status;
              approvalConclusion = approvalCheck.data.conclusion;

              if (approvalState !== 'completed') {
                console.log(`Approval status: ${approvalState}, waiting...`);
                await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
              }
            }

            if (approvalConclusion !== 'success') {
              core.setFailed(`Approval failed with conclusion: ${approvalConclusion}`);
            } else {
                console.log("Approval successful, proceeding with deployment...");
            }
                          
      # # 12) Push Docker Image to ECR
      # - name: Push Docker Image to ECR
      #   run: |
      #     docker push ${{ env.ECR_URI }}:${{ steps.semver.outputs.version_tag }}
      #     docker push ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest

      # 13) Log deployment information
      - name: Log Deployment Info
        run: |
          echo "✅ Successfully pushed image to ECR: ${{ env.ECR_URI }}:${{ github.event.inputs.aws_env }}-latest"
          echo "✅ EventBridge will automatically deploy the new image"
          
          # Add information about the environment and microservice
          echo "Environment: ${{ github.event.inputs.aws_env }}"
          echo "Microservice: ${{ github.event.inputs.microservice }}"
          echo "ECR URI: ${{ env.ECR_URI }}:${{ steps.semver.outputs.version_tag }}"

      # 14) Create GitHub Summary
      - name: Add Summary
        if: ${{ always() }}
        uses: actions/github-script@v6
        with:
          script: |
            const version = '${{ steps.semver.outputs.version_tag }}';
            const env = '${{ github.event.inputs.aws_env }}';
            const microservice = '${{ github.event.inputs.microservice }}';
            const ecr = '${{ env.ECR_URI }}';
            const repoName = '${{ env.REPO_NAME }}';

            core.summary
              .addHeading("ODS Deployment Summary")
              .addTable([
                [{ data: "Version", header: true }, { data: "Environment", header: true }, { data: "Microservice", header: true }, { data: "Repository", header: true }],
                [version, env, microservice, repoName],
              ])
              .addHeading("Image Details")
              .addRaw(`ECR URI: ${ecr}:${version}`)
              .addRaw(`Latest Tag: ${ecr}:${env}-latest`)
              .write()

      # 15) (Optional) Save Docker Image as Artifact
      - name: Save Docker Image as Artifact
        run: |
          echo "Saving Docker image ${{ env.ECR_URI }}:${{ steps.semver.outputs.version_tag }} as an artifact"
          docker save ${{ env.ECR_URI }}:${{ steps.semver.outputs.version_tag }} | gzip > ods_${{ steps.semver.outputs.version_tag }}.tar.gz

      # 16) (Optional) Upload Docker Image Artifact
      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ steps.semver.outputs.version_tag }}
          path: ods_${{ steps.semver.outputs.version_tag }}.tar.gz

      # Trigger Approval Workflow for Next Environment
      - name: Trigger Approval for Next Environment
        if: ${{ always() }}
        uses: actions/github-script@v6
        with:
          script: |
            const version = '${{ steps.semver.outputs.version_tag  }}';
            const runId = '${{ steps.get_run_id.outputs.run_id }}';
            console.log(`Version: ${version}, Run ID: ${runId}`);
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'qa-push.yaml',
              ref: 'main',
              inputs: {
                version: version,
                run_id: runId
              }
            });